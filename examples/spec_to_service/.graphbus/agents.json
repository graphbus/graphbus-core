[
  {
    "name": "ModelAgent",
    "module": "examples.spec_to_service.agents.model",
    "class_name": "ModelAgent",
    "source_file": "/home/ubuntu/workbench/graphbus-core/examples/spec_to_service/agents/model.py",
    "source_code": "\"\"\"\nModelAgent - Generates Pydantic models from data model specifications.\n\"\"\"\n\nfrom graphbus_core import GraphBusNode, schema_method, depends_on\n\n\n@depends_on(\"SpecParserAgent\")\nclass ModelAgent(GraphBusNode):\n    SYSTEM_PROMPT = \"You generate Pydantic models from data model specifications.\"\n\n    # Mapping from spec type names to Python type annotations\n    TYPE_MAP = {\n        'str': 'str',\n        'int': 'int',\n        'float': 'float',\n        'bool': 'bool',\n        'list': 'list',\n        'dict': 'dict',\n    }\n\n    @schema_method(\n        input_schema={\"models\": list},\n        output_schema={\"models_code\": str}\n    )\n    def generate_models(self, models: list) -> dict:\n        \"\"\"Generate Pydantic model code from a list of model definitions.\"\"\"\n        if not models:\n            raise ValueError(\"'models' must be a non-empty list\")\n\n        lines = [\n            '\"\"\"',\n            'Pydantic models for the service',\n            '\"\"\"',\n            '',\n            'from typing import Optional',\n            '',\n            'from pydantic import BaseModel',\n            '',\n        ]\n\n        for model_def in models:\n            name = model_def['name']\n            fields = model_def.get('fields', [])\n\n            # --- Main response model (all fields, id is required) ---\n            lines.append(f'class {name}(BaseModel):')\n            lines.append(f'    \"\"\"Schema for {name}.\"\"\"')\n            for field in fields:\n                lines.append(self._render_field(field))\n            lines.append('')\n            lines.append('')\n\n            # --- Create model (no id, required fields only) ---\n            create_fields = [f for f in fields if f['name'] != 'id']\n            lines.append(f'class {name}Create(BaseModel):')\n            lines.append(f'    \"\"\"Schema for creating a {name}.\"\"\"')\n            for field in create_fields:\n                lines.append(self._render_field(field))\n            lines.append('')\n            lines.append('')\n\n            # --- Update model (all fields optional) ---\n            update_fields = [f for f in fields if f['name'] != 'id']\n            lines.append(f'class {name}Update(BaseModel):')\n            lines.append(f'    \"\"\"Schema for updating a {name}.\"\"\"')\n            for field in update_fields:\n                lines.append(self._render_field(field, force_optional=True))\n            lines.append('')\n            lines.append('')\n\n            # --- Assign request model (if user_id field exists) ---\n            if any(f['name'] == 'user_id' for f in fields):\n                lines.append(f'class AssignRequest(BaseModel):')\n                lines.append(f'    \"\"\"Schema for assigning a resource to a user.\"\"\"')\n                lines.append(f'    user_id: int')\n                lines.append('')\n                lines.append('')\n\n        return {\"models_code\": '\\n'.join(lines)}\n\n    # ------------------------------------------------------------------\n    # Helpers\n    # ------------------------------------------------------------------\n\n    def _render_field(self, field: dict, force_optional: bool = False) -> str:\n        \"\"\"Render a single Pydantic field line.\"\"\"\n        name = field['name']\n        py_type = self.TYPE_MAP.get(field.get('type', 'str'), 'str')\n        optional = force_optional or field.get('optional', False)\n        default = field.get('default')\n\n        if force_optional:\n            # Update models: everything is Optional with None default\n            return f'    {name}: Optional[{py_type}] = None'\n        elif optional:\n            if default is not None:\n                return f'    {name}: Optional[{py_type}] = \"{default}\"' if isinstance(default, str) else f'    {name}: Optional[{py_type}] = {default}'\n            return f'    {name}: Optional[{py_type}] = None'\n        else:\n            if default is not None:\n                return f'    {name}: {py_type} = \"{default}\"' if isinstance(default, str) else f'    {name}: {py_type} = {default}'\n            return f'    {name}: {py_type}'\n",
    "system_prompt": {
      "text": "You generate Pydantic models from data model specifications.",
      "role": null,
      "capabilities": []
    },
    "methods": [
      {
        "name": "generate_models",
        "input_schema": {
          "fields": {
            "models": "list"
          },
          "description": null
        },
        "output_schema": {
          "fields": {
            "models_code": "str"
          },
          "description": null
        },
        "description": "Generate Pydantic model code from a list of model definitions."
      }
    ],
    "subscriptions": [],
    "dependencies": [
      "SpecParserAgent"
    ],
    "is_arbiter": false,
    "metadata": {}
  },
  {
    "name": "OrchestratorAgent",
    "module": "examples.spec_to_service.agents.orchestrator",
    "class_name": "OrchestratorAgent",
    "source_file": "/home/ubuntu/workbench/graphbus-core/examples/spec_to_service/agents/orchestrator.py",
    "source_code": "\"\"\"\nOrchestratorAgent - Coordinates the full spec-to-service pipeline.\n\"\"\"\n\nimport os\n\nfrom graphbus_core import GraphBusNode, schema_method, depends_on\n\nfrom .spec_parser import SpecParserAgent\nfrom .router import RouterAgent\nfrom .model import ModelAgent\nfrom .test_writer import TestAgent\n\n\n@depends_on(\"RouterAgent\", \"ModelAgent\", \"TestAgent\")\nclass OrchestratorAgent(GraphBusNode):\n    SYSTEM_PROMPT = \"You coordinate the full spec-to-service pipeline.\"\n\n    @schema_method(\n        input_schema={\"spec\": str, \"service_name\": str},\n        output_schema={\"output_dir\": str, \"files_written\": list}\n    )\n    def build_service(self, spec: str, service_name: str) -> dict:\n        \"\"\"Run the full spec-to-service pipeline and write output files.\"\"\"\n        if not isinstance(spec, str) or not spec.strip():\n            raise ValueError(\"'spec' must be a non-empty string\")\n        if not isinstance(service_name, str) or not service_name.strip():\n            raise ValueError(\"'service_name' must be a non-empty string\")\n\n        # Step 1 \u2014 Parse the spec\n        parser = SpecParserAgent()\n        parsed = parser.parse_spec(spec)\n        endpoints = parsed['endpoints']\n        models = parsed['models']\n        auth_required = parsed['auth_required']\n\n        print(f\"[OrchestratorAgent] Parsed spec: {len(endpoints)} endpoints, \"\n              f\"{len(models)} models, auth={auth_required}\")\n\n        # Step 2 \u2014 Generate code (router + models in parallel in concept)\n        router_agent = RouterAgent()\n        router_result = router_agent.generate_router(endpoints, service_name)\n        router_code = router_result['router_code']\n\n        model_agent = ModelAgent()\n        model_result = model_agent.generate_models(models)\n        models_code = model_result['models_code']\n\n        # Step 3 \u2014 Generate tests\n        test_agent = TestAgent()\n        test_result = test_agent.generate_tests(endpoints, service_name)\n        test_code = test_result['test_code']\n\n        # Step 4 \u2014 Generate main.py entry point\n        main_code = self._generate_main(service_name)\n\n        # Step 5 \u2014 Write output files\n        output_dir = os.path.join(\n            os.path.dirname(os.path.dirname(os.path.abspath(__file__))),\n            'output'\n        )\n        os.makedirs(output_dir, exist_ok=True)\n\n        files = {\n            'models.py': models_code,\n            'router.py': router_code,\n            'test_router.py': test_code,\n            'main.py': main_code,\n        }\n\n        files_written = []\n        for filename, content in files.items():\n            filepath = os.path.join(output_dir, filename)\n            with open(filepath, 'w') as f:\n                f.write(content)\n            files_written.append(filepath)\n            print(f\"[OrchestratorAgent] Wrote {filepath}\")\n\n        return {\n            \"output_dir\": output_dir,\n            \"files_written\": files_written,\n        }\n\n    # ------------------------------------------------------------------\n    # Helpers\n    # ------------------------------------------------------------------\n\n    @staticmethod\n    def _generate_main(service_name: str) -> str:\n        \"\"\"Generate a main.py FastAPI app entry point.\"\"\"\n        return '\\n'.join([\n            '\"\"\"',\n            f'{service_name} - FastAPI application entry point',\n            '\"\"\"',\n            '',\n            'from fastapi import FastAPI',\n            '',\n            'from router import router',\n            '',\n            f'app = FastAPI(title=\"{service_name}\")',\n            'app.include_router(router)',\n            '',\n            '',\n            'if __name__ == \"__main__\":',\n            '    import uvicorn',\n            '    uvicorn.run(app, host=\"0.0.0.0\", port=8000)',\n            '',\n        ])\n",
    "system_prompt": {
      "text": "You coordinate the full spec-to-service pipeline.",
      "role": null,
      "capabilities": []
    },
    "methods": [
      {
        "name": "build_service",
        "input_schema": {
          "fields": {
            "spec": "str",
            "service_name": "str"
          },
          "description": null
        },
        "output_schema": {
          "fields": {
            "output_dir": "str",
            "files_written": "list"
          },
          "description": null
        },
        "description": "Run the full spec-to-service pipeline and write output files."
      }
    ],
    "subscriptions": [],
    "dependencies": [
      "RouterAgent",
      "ModelAgent",
      "TestAgent"
    ],
    "is_arbiter": false,
    "metadata": {}
  },
  {
    "name": "RouterAgent",
    "module": "examples.spec_to_service.agents.router",
    "class_name": "RouterAgent",
    "source_file": "/home/ubuntu/workbench/graphbus-core/examples/spec_to_service/agents/router.py",
    "source_code": "\"\"\"\nRouterAgent - Generates FastAPI router code from endpoint specifications.\n\"\"\"\n\nfrom graphbus_core import GraphBusNode, schema_method, depends_on\n\n\n@depends_on(\"SpecParserAgent\")\nclass RouterAgent(GraphBusNode):\n    SYSTEM_PROMPT = \"You generate FastAPI router code from endpoint specifications.\"\n\n    @schema_method(\n        input_schema={\"endpoints\": list, \"service_name\": str},\n        output_schema={\"router_code\": str}\n    )\n    def generate_router(self, endpoints: list, service_name: str) -> dict:\n        \"\"\"Generate a FastAPI router module from a list of endpoint definitions.\"\"\"\n        if not endpoints:\n            raise ValueError(\"'endpoints' must be a non-empty list\")\n        if not isinstance(service_name, str) or not service_name.strip():\n            raise ValueError(\"'service_name' must be a non-empty string\")\n\n        lines = [\n            '\"\"\"',\n            f'FastAPI router for {service_name}',\n            '\"\"\"',\n            '',\n            'from typing import List, Optional',\n            '',\n            'from fastapi import APIRouter, HTTPException, Query',\n            '',\n            'from models import (',\n        ]\n\n        # Collect model names referenced by endpoints\n        model_names = set()\n        for ep in endpoints:\n            if ep.get('response_model'):\n                model_names.add(ep['response_model'])\n            if ep.get('request_body'):\n                model_names.add(ep['request_body'])\n        for m in sorted(model_names):\n            lines.append(f'    {m},')\n        lines.append(')')\n        lines.append('')\n        lines.append(f'router = APIRouter(prefix=\"\", tags=[\"{service_name}\"])')\n        lines.append('')\n\n        # In-memory store\n        resource = self._detect_resource(endpoints)\n        lines.append(f'# In-memory store for demo purposes')\n        lines.append(f'{resource}_db: dict[int, dict] = {{}}')\n        lines.append(f'_next_id: int = 1')\n        lines.append('')\n\n        # Sort endpoints: static paths before parameterised paths so\n        # FastAPI matches /tasks/filter before /tasks/{task_id}\n        sorted_eps = sorted(endpoints, key=lambda e: ('{' in e['path'], e['path']))\n\n        for ep in sorted_eps:\n            lines.extend(self._render_endpoint(ep, resource))\n            lines.append('')\n\n        return {\"router_code\": '\\n'.join(lines)}\n\n    # ------------------------------------------------------------------\n    # Helpers\n    # ------------------------------------------------------------------\n\n    @staticmethod\n    def _detect_resource(endpoints: list) -> str:\n        \"\"\"Detect the main resource name from endpoint paths.\"\"\"\n        for ep in endpoints:\n            parts = ep['path'].strip('/').split('/')\n            if parts:\n                return parts[0]\n        return 'items'\n\n    def _render_endpoint(self, ep: dict, resource: str) -> list:\n        \"\"\"Render a single endpoint as FastAPI route code lines.\"\"\"\n        method = ep['method'].lower()\n        path = ep['path']\n        desc = ep.get('description', '')\n        request_body = ep.get('request_body')\n        response_model = ep.get('response_model')\n        query_params = ep.get('query_params', [])\n\n        singular = resource.rstrip('s')\n        id_param = f'{singular}_id'\n\n        lines = []\n\n        # --- LIST all ---\n        if method == 'get' and path == f'/{resource}':\n            resp = f', response_model=List[{response_model}]' if response_model else ''\n            lines.append(f'@router.get(\"/{resource}\"{resp})')\n            lines.append(f'def list_{resource}():')\n            lines.append(f'    \"\"\"List all {resource}.\"\"\"')\n            lines.append(f'    return [{{**v, \"id\": k}} for k, v in {resource}_db.items()]')\n\n        # --- FILTER ---\n        elif method == 'get' and '/filter' in path:\n            resp = f', response_model=List[{response_model}]' if response_model else ''\n            params_sig = ', '.join(\n                f'{p}: Optional[str] = Query(None)' for p in query_params\n            )\n            lines.append(f'@router.get(\"/{resource}/filter\"{resp})')\n            lines.append(f'def filter_{resource}({params_sig}):')\n            lines.append(f'    \"\"\"Filter {resource} by query parameters.\"\"\"')\n            lines.append(f'    results = list({resource}_db.values())')\n            for p in query_params:\n                lines.append(f'    if {p} is not None:')\n                lines.append(f'        results = [r for r in results if r.get(\"{p}\") == {p}]')\n            lines.append(f'    return results')\n\n        # --- GET by id ---\n        elif method == 'get' and f'{{{id_param}}}' in path:\n            resp = f', response_model={response_model}' if response_model else ''\n            lines.append(f'@router.get(\"/{resource}/{{{id_param}}}\"{resp})')\n            lines.append(f'def get_{singular}({id_param}: int):')\n            lines.append(f'    \"\"\"Get a {singular} by ID.\"\"\"')\n            lines.append(f'    if {id_param} not in {resource}_db:')\n            lines.append(f'        raise HTTPException(status_code=404, detail=\"{singular.title()} not found\")')\n            lines.append(f'    return {{**{resource}_db[{id_param}], \"id\": {id_param}}}')\n\n        # --- CREATE ---\n        elif method == 'post' and path == f'/{resource}':\n            resp = f', response_model={response_model}' if response_model else ''\n            body = f'payload: {request_body}' if request_body else ''\n            lines.append(f'@router.post(\"/{resource}\"{resp}, status_code=201)')\n            lines.append(f'def create_{singular}({body}):')\n            lines.append(f'    \"\"\"Create a new {singular}.\"\"\"')\n            lines.append(f'    global _next_id')\n            lines.append(f'    data = payload.model_dump()')\n            lines.append(f'    {resource}_db[_next_id] = data')\n            lines.append(f'    result = {{**data, \"id\": _next_id}}')\n            lines.append(f'    _next_id += 1')\n            lines.append(f'    return result')\n\n        # --- UPDATE ---\n        elif method == 'put' and path == f'/{resource}/{{{id_param}}}':\n            resp = f', response_model={response_model}' if response_model else ''\n            body = f'{id_param}: int, payload: {request_body}' if request_body else f'{id_param}: int'\n            lines.append(f'@router.put(\"/{resource}/{{{id_param}}}\"{resp})')\n            lines.append(f'def update_{singular}({body}):')\n            lines.append(f'    \"\"\"Update an existing {singular}.\"\"\"')\n            lines.append(f'    if {id_param} not in {resource}_db:')\n            lines.append(f'        raise HTTPException(status_code=404, detail=\"{singular.title()} not found\")')\n            lines.append(f'    updates = payload.model_dump(exclude_unset=True)')\n            lines.append(f'    {resource}_db[{id_param}].update(updates)')\n            lines.append(f'    return {{**{resource}_db[{id_param}], \"id\": {id_param}}}')\n\n        # --- DELETE ---\n        elif method == 'delete':\n            lines.append(f'@router.delete(\"/{resource}/{{{id_param}}}\", status_code=204)')\n            lines.append(f'def delete_{singular}({id_param}: int):')\n            lines.append(f'    \"\"\"Delete a {singular}.\"\"\"')\n            lines.append(f'    if {id_param} not in {resource}_db:')\n            lines.append(f'        raise HTTPException(status_code=404, detail=\"{singular.title()} not found\")')\n            lines.append(f'    del {resource}_db[{id_param}]')\n            lines.append(f'    return None')\n\n        # --- ASSIGN ---\n        elif method == 'put' and '/assign' in path:\n            resp = f', response_model={response_model}' if response_model else ''\n            body = f'{id_param}: int, payload: {request_body}' if request_body else f'{id_param}: int'\n            lines.append(f'@router.put(\"/{resource}/{{{id_param}}}/assign\"{resp})')\n            lines.append(f'def assign_{singular}({body}):')\n            lines.append(f'    \"\"\"Assign {singular} to a user.\"\"\"')\n            lines.append(f'    if {id_param} not in {resource}_db:')\n            lines.append(f'        raise HTTPException(status_code=404, detail=\"{singular.title()} not found\")')\n            lines.append(f'    {resource}_db[{id_param}][\"user_id\"] = payload.user_id')\n            lines.append(f'    return {{**{resource}_db[{id_param}], \"id\": {id_param}}}')\n\n        # --- MARK COMPLETE ---\n        elif method == 'put' and '/complete' in path:\n            resp = f', response_model={response_model}' if response_model else ''\n            lines.append(f'@router.put(\"/{resource}/{{{id_param}}}/complete\"{resp})')\n            lines.append(f'def complete_{singular}({id_param}: int):')\n            lines.append(f'    \"\"\"Mark {singular} as complete.\"\"\"')\n            lines.append(f'    if {id_param} not in {resource}_db:')\n            lines.append(f'        raise HTTPException(status_code=404, detail=\"{singular.title()} not found\")')\n            lines.append(f'    {resource}_db[{id_param}][\"status\"] = \"completed\"')\n            lines.append(f'    return {{**{resource}_db[{id_param}], \"id\": {id_param}}}')\n\n        else:\n            # Fallback for unrecognised patterns\n            lines.append(f'# TODO: implement {method.upper()} {path} \u2014 {desc}')\n\n        return lines\n",
    "system_prompt": {
      "text": "You generate FastAPI router code from endpoint specifications.",
      "role": null,
      "capabilities": []
    },
    "methods": [
      {
        "name": "generate_router",
        "input_schema": {
          "fields": {
            "endpoints": "list",
            "service_name": "str"
          },
          "description": null
        },
        "output_schema": {
          "fields": {
            "router_code": "str"
          },
          "description": null
        },
        "description": "Generate a FastAPI router module from a list of endpoint definitions."
      }
    ],
    "subscriptions": [],
    "dependencies": [
      "SpecParserAgent"
    ],
    "is_arbiter": false,
    "metadata": {}
  },
  {
    "name": "SpecParserAgent",
    "module": "examples.spec_to_service.agents.spec_parser",
    "class_name": "SpecParserAgent",
    "source_file": "/home/ubuntu/workbench/graphbus-core/examples/spec_to_service/agents/spec_parser.py",
    "source_code": "\"\"\"\nSpecParserAgent - Extracts structured API requirements from plain-English specs.\n\"\"\"\n\nimport re\n\nfrom graphbus_core import GraphBusNode, schema_method, subscribe\n\n\nclass SpecParserAgent(GraphBusNode):\n    SYSTEM_PROMPT = \"You extract structured API requirements from plain-English specs.\"\n\n    @schema_method(\n        input_schema={\"spec\": str},\n        output_schema={\"endpoints\": list, \"models\": list, \"auth_required\": bool}\n    )\n    def parse_spec(self, spec: str) -> dict:\n        \"\"\"Parse a plain-English spec string into structured API requirements.\"\"\"\n        if not isinstance(spec, str) or not spec.strip():\n            raise ValueError(\"'spec' must be a non-empty string\")\n\n        spec_lower = spec.lower()\n        endpoints = []\n        models = []\n\n        # --- Extract resource name and fields from CRUD pattern ---\n        # Matches: \"CRUD operations for <resource> (<field1>, <field2>, ...)\"\n        crud_match = re.search(\n            r'crud\\s+operations?\\s+for\\s+(\\w+)\\s*\\(([^)]+)\\)',\n            spec_lower\n        )\n\n        resource_name = None\n        resource_fields = []\n\n        if crud_match:\n            resource_name = crud_match.group(1).rstrip('s')  # singularise\n            raw_fields = [f.strip() for f in crud_match.group(2).split(',')]\n            resource_fields = self._parse_fields(raw_fields)\n\n            # Standard CRUD endpoints\n            plural = resource_name + 's'\n            endpoints.extend([\n                {\"method\": \"GET\", \"path\": f\"/{plural}\", \"description\": f\"List all {plural}\",\n                 \"query_params\": [], \"request_body\": None, \"response_model\": f\"{resource_name.title()}\"},\n                {\"method\": \"POST\", \"path\": f\"/{plural}\", \"description\": f\"Create a {resource_name}\",\n                 \"query_params\": [], \"request_body\": f\"{resource_name.title()}Create\", \"response_model\": f\"{resource_name.title()}\"},\n                {\"method\": \"GET\", \"path\": f\"/{plural}/{{{resource_name}_id}}\", \"description\": f\"Get a {resource_name} by ID\",\n                 \"query_params\": [], \"request_body\": None, \"response_model\": f\"{resource_name.title()}\"},\n                {\"method\": \"PUT\", \"path\": f\"/{plural}/{{{resource_name}_id}}\", \"description\": f\"Update a {resource_name}\",\n                 \"query_params\": [], \"request_body\": f\"{resource_name.title()}Update\", \"response_model\": f\"{resource_name.title()}\"},\n                {\"method\": \"DELETE\", \"path\": f\"/{plural}/{{{resource_name}_id}}\", \"description\": f\"Delete a {resource_name}\",\n                 \"query_params\": [], \"request_body\": None, \"response_model\": None},\n            ])\n\n        # --- Detect additional operations ---\n        # User assignment\n        if re.search(r'assign.*user|user.*assign', spec_lower) and resource_name:\n            plural = resource_name + 's'\n            endpoints.append({\n                \"method\": \"PUT\",\n                \"path\": f\"/{plural}/{{{resource_name}_id}}/assign\",\n                \"description\": f\"Assign {resource_name} to a user\",\n                \"query_params\": [],\n                \"request_body\": \"AssignRequest\",\n                \"response_model\": f\"{resource_name.title()}\",\n            })\n            # Ensure user_id field exists on the resource model\n            if not any(f['name'] == 'user_id' for f in resource_fields):\n                resource_fields.append(\n                    {\"name\": \"user_id\", \"type\": \"int\", \"optional\": True}\n                )\n\n        # Filtering\n        filter_match = re.search(r'filter\\s+\\w+\\s+by\\s+([\\w\\s,]+?)(?:\\n|$|\\.)', spec_lower)\n        if filter_match and resource_name:\n            filter_fields = [f.strip() for f in filter_match.group(1).split(' and ')]\n            # flatten comma-separated too\n            expanded = []\n            for f in filter_fields:\n                expanded.extend([x.strip() for x in f.split(',')])\n            plural = resource_name + 's'\n            endpoints.append({\n                \"method\": \"GET\",\n                \"path\": f\"/{plural}/filter\",\n                \"description\": f\"Filter {plural} by {', '.join(expanded)}\",\n                \"query_params\": expanded,\n                \"request_body\": None,\n                \"response_model\": f\"{resource_name.title()}\",\n            })\n\n        # Mark complete\n        if re.search(r'mark\\s+\\w+\\s+complete', spec_lower) and resource_name:\n            plural = resource_name + 's'\n            endpoints.append({\n                \"method\": \"PUT\",\n                \"path\": f\"/{plural}/{{{resource_name}_id}}/complete\",\n                \"description\": f\"Mark {resource_name} as complete\",\n                \"query_params\": [],\n                \"request_body\": None,\n                \"response_model\": f\"{resource_name.title()}\",\n            })\n\n        # --- Build model definitions ---\n        if resource_name and resource_fields:\n            models.append({\n                \"name\": resource_name.title(),\n                \"fields\": resource_fields,\n            })\n\n        # --- Detect auth requirement ---\n        auth_required = not bool(re.search(r'no\\s+auth', spec_lower))\n\n        return {\n            \"endpoints\": endpoints,\n            \"models\": models,\n            \"auth_required\": auth_required,\n        }\n\n    @subscribe(\"/Pipeline/SpecSubmitted\")\n    def on_spec_submitted(self, event):\n        \"\"\"Handle spec submission events \u2014 triggers parsing automatically.\"\"\"\n        spec = event.get('spec', '')\n        result = self.parse_spec(spec)\n        print(f\"[SpecParserAgent] Parsed spec: {len(result['endpoints'])} endpoints, \"\n              f\"{len(result['models'])} models, auth={result['auth_required']}\")\n        return result\n\n    # ------------------------------------------------------------------\n    # Internal helpers\n    # ------------------------------------------------------------------\n\n    @staticmethod\n    def _parse_fields(raw_fields: list) -> list:\n        \"\"\"Infer field types from raw field name strings.\"\"\"\n        type_hints = {\n            'id': ('int', False),\n            'name': ('str', False),\n            'title': ('str', False),\n            'description': ('str', True),\n            'status': ('str', False),\n            'priority': ('str', False),\n            'due_date': ('str', True),\n            'created_at': ('str', True),\n            'updated_at': ('str', True),\n            'user_id': ('int', True),\n            'email': ('str', False),\n            'price': ('float', False),\n            'amount': ('float', False),\n            'count': ('int', False),\n            'is_active': ('bool', False),\n            'completed': ('bool', False),\n        }\n        fields = []\n        for raw in raw_fields:\n            name = raw.strip().replace(' ', '_')\n            inferred_type, optional = type_hints.get(name, ('str', True))\n            field = {\"name\": name, \"type\": inferred_type, \"optional\": optional}\n            # Provide sensible defaults for status/priority\n            if name == 'status':\n                field['default'] = 'pending'\n            elif name == 'priority':\n                field['default'] = 'medium'\n            fields.append(field)\n        return fields\n",
    "system_prompt": {
      "text": "You extract structured API requirements from plain-English specs.",
      "role": null,
      "capabilities": []
    },
    "methods": [
      {
        "name": "parse_spec",
        "input_schema": {
          "fields": {
            "spec": "str"
          },
          "description": null
        },
        "output_schema": {
          "fields": {
            "endpoints": "list",
            "models": "list",
            "auth_required": "bool"
          },
          "description": null
        },
        "description": "Parse a plain-English spec string into structured API requirements."
      }
    ],
    "subscriptions": [
      {
        "node_name": "SpecParserAgent",
        "topic": "/Pipeline/SpecSubmitted",
        "handler_name": "on_spec_submitted"
      }
    ],
    "dependencies": [],
    "is_arbiter": false,
    "metadata": {}
  },
  {
    "name": "TestAgent",
    "module": "examples.spec_to_service.agents.test_writer",
    "class_name": "TestAgent",
    "source_file": "/home/ubuntu/workbench/graphbus-core/examples/spec_to_service/agents/test_writer.py",
    "source_code": "\"\"\"\nTestAgent - Writes pytest test stubs for FastAPI endpoints.\n\"\"\"\n\nfrom graphbus_core import GraphBusNode, schema_method, subscribe, depends_on\n\n\n@depends_on(\"RouterAgent\")\nclass TestAgent(GraphBusNode):\n    SYSTEM_PROMPT = \"You write pytest test stubs for FastAPI endpoints.\"\n\n    @schema_method(\n        input_schema={\"endpoints\": list, \"service_name\": str},\n        output_schema={\"test_code\": str}\n    )\n    def generate_tests(self, endpoints: list, service_name: str) -> dict:\n        \"\"\"Generate pytest test stubs covering all endpoints.\"\"\"\n        if not endpoints:\n            raise ValueError(\"'endpoints' must be a non-empty list\")\n\n        lines = [\n            '\"\"\"',\n            f'Tests for {service_name}',\n            '\"\"\"',\n            '',\n            'import pytest',\n            'from fastapi.testclient import TestClient',\n            '',\n            'from main import app',\n            '',\n            '',\n            '@pytest.fixture',\n            'def client():',\n            '    \"\"\"Create a test client.\"\"\"',\n            '    return TestClient(app)',\n            '',\n        ]\n\n        resource = self._detect_resource(endpoints)\n        singular = resource.rstrip('s')\n\n        # Helper: create a sample resource for tests that need one\n        lines.extend([\n            '',\n            f'@pytest.fixture',\n            f'def sample_{singular}(client):',\n            f'    \"\"\"Create a sample {singular} for testing.\"\"\"',\n            f'    payload = {self._sample_create_payload(singular)}',\n            f'    response = client.post(\"/{resource}\", json=payload)',\n            f'    assert response.status_code == 201',\n            f'    return response.json()',\n            '',\n            '',\n        ])\n\n        for ep in endpoints:\n            lines.extend(self._render_test(ep, resource, singular))\n            lines.append('')\n\n        return {\"test_code\": '\\n'.join(lines)}\n\n    @subscribe(\"/Service/Generated\")\n    def on_service_generated(self, event):\n        \"\"\"Auto-generate tests when a service is generated.\"\"\"\n        endpoints = event.get('endpoints', [])\n        service_name = event.get('service_name', 'service')\n        result = self.generate_tests(endpoints, service_name)\n        print(f\"[TestAgent] Generated test stubs for {len(endpoints)} endpoints\")\n        return result\n\n    # ------------------------------------------------------------------\n    # Helpers\n    # ------------------------------------------------------------------\n\n    @staticmethod\n    def _detect_resource(endpoints: list) -> str:\n        for ep in endpoints:\n            parts = ep['path'].strip('/').split('/')\n            if parts:\n                return parts[0]\n        return 'items'\n\n    @staticmethod\n    def _sample_create_payload(singular: str) -> str:\n        \"\"\"Return a representative JSON payload for creating a resource.\"\"\"\n        if singular == 'task':\n            return '{\"title\": \"Test task\", \"description\": \"A task for testing\", \"status\": \"pending\", \"priority\": \"medium\"}'\n        return '{\"name\": \"Test item\"}'\n\n    def _render_test(self, ep: dict, resource: str, singular: str) -> list:\n        \"\"\"Render a single test function.\"\"\"\n        method = ep['method'].lower()\n        path = ep['path']\n        desc = ep.get('description', f'{method.upper()} {path}')\n        func_name = self._test_name(method, path, resource, singular)\n\n        lines = []\n\n        # --- LIST ---\n        if method == 'get' and path == f'/{resource}':\n            lines.extend([\n                f'def test_{func_name}(client):',\n                f'    \"\"\"Test: {desc}.\"\"\"',\n                f'    response = client.get(\"/{resource}\")',\n                f'    assert response.status_code == 200',\n                f'    assert isinstance(response.json(), list)',\n            ])\n\n        # --- FILTER ---\n        elif method == 'get' and '/filter' in path:\n            qparams = ep.get('query_params', [])\n            qs = '&'.join(f'{p}=test' for p in qparams) if qparams else ''\n            url = f'/{resource}/filter?{qs}' if qs else f'/{resource}/filter'\n            lines.extend([\n                f'def test_{func_name}(client, sample_{singular}):',\n                f'    \"\"\"Test: {desc}.\"\"\"',\n                f'    response = client.get(\"{url}\")',\n                f'    assert response.status_code == 200',\n                f'    assert isinstance(response.json(), list)',\n            ])\n\n        # --- GET by id ---\n        elif method == 'get' and f'{{{singular}_id}}' in path:\n            lines.extend([\n                f'def test_{func_name}(client, sample_{singular}):',\n                f'    \"\"\"Test: {desc}.\"\"\"',\n                f'    {singular}_id = sample_{singular}[\"id\"]',\n                f'    response = client.get(f\"/{resource}/{{{singular}_id}}\")',\n                f'    assert response.status_code == 200',\n                f'    assert response.json()[\"id\"] == {singular}_id',\n            ])\n            lines.append('')\n            lines.extend([\n                f'def test_{func_name}_not_found(client):',\n                f'    \"\"\"Test: {desc} with invalid ID.\"\"\"',\n                f'    response = client.get(\"/{resource}/99999\")',\n                f'    assert response.status_code == 404',\n            ])\n\n        # --- CREATE ---\n        elif method == 'post':\n            lines.extend([\n                f'def test_{func_name}(client):',\n                f'    \"\"\"Test: {desc}.\"\"\"',\n                f'    payload = {self._sample_create_payload(singular)}',\n                f'    response = client.post(\"/{resource}\", json=payload)',\n                f'    assert response.status_code == 201',\n                f'    data = response.json()',\n                f'    assert \"id\" in data',\n            ])\n\n        # --- UPDATE ---\n        elif method == 'put' and path == f'/{resource}/{{{singular}_id}}':\n            lines.extend([\n                f'def test_{func_name}(client, sample_{singular}):',\n                f'    \"\"\"Test: {desc}.\"\"\"',\n                f'    {singular}_id = sample_{singular}[\"id\"]',\n                f'    response = client.put(',\n                f'        f\"/{resource}/{{{singular}_id}}\",',\n                f'        json={{\"title\": \"Updated title\"}}',\n                f'    )',\n                f'    assert response.status_code == 200',\n                f'    assert response.json()[\"title\"] == \"Updated title\"',\n            ])\n\n        # --- DELETE ---\n        elif method == 'delete':\n            lines.extend([\n                f'def test_{func_name}(client, sample_{singular}):',\n                f'    \"\"\"Test: {desc}.\"\"\"',\n                f'    {singular}_id = sample_{singular}[\"id\"]',\n                f'    response = client.delete(f\"/{resource}/{{{singular}_id}}\")',\n                f'    assert response.status_code == 204',\n                f'    # Verify deletion',\n                f'    response = client.get(f\"/{resource}/{{{singular}_id}}\")',\n                f'    assert response.status_code == 404',\n            ])\n\n        # --- ASSIGN ---\n        elif method == 'put' and '/assign' in path:\n            lines.extend([\n                f'def test_{func_name}(client, sample_{singular}):',\n                f'    \"\"\"Test: {desc}.\"\"\"',\n                f'    {singular}_id = sample_{singular}[\"id\"]',\n                f'    response = client.put(',\n                f'        f\"/{resource}/{{{singular}_id}}/assign\",',\n                f'        json={{\"user_id\": 42}}',\n                f'    )',\n                f'    assert response.status_code == 200',\n                f'    assert response.json()[\"user_id\"] == 42',\n            ])\n\n        # --- MARK COMPLETE ---\n        elif method == 'put' and '/complete' in path:\n            lines.extend([\n                f'def test_{func_name}(client, sample_{singular}):',\n                f'    \"\"\"Test: {desc}.\"\"\"',\n                f'    {singular}_id = sample_{singular}[\"id\"]',\n                f'    response = client.put(f\"/{resource}/{{{singular}_id}}/complete\")',\n                f'    assert response.status_code == 200',\n                f'    assert response.json()[\"status\"] == \"completed\"',\n            ])\n\n        else:\n            lines.extend([\n                f'def test_{func_name}(client):',\n                f'    \"\"\"Test: {desc} (stub).\"\"\"',\n                f'    pytest.skip(\"Not yet implemented\")',\n            ])\n\n        return lines\n\n    @staticmethod\n    def _test_name(method: str, path: str, resource: str, singular: str) -> str:\n        \"\"\"Generate a descriptive test function name from an endpoint.\"\"\"\n        if method == 'get' and path == f'/{resource}':\n            return f'list_{resource}'\n        if method == 'get' and '/filter' in path:\n            return f'filter_{resource}'\n        if method == 'get':\n            return f'get_{singular}'\n        if method == 'post':\n            return f'create_{singular}'\n        if method == 'put' and '/assign' in path:\n            return f'assign_{singular}'\n        if method == 'put' and '/complete' in path:\n            return f'complete_{singular}'\n        if method == 'put':\n            return f'update_{singular}'\n        if method == 'delete':\n            return f'delete_{singular}'\n        safe = path.replace('/', '_').replace('{', '').replace('}', '').strip('_')\n        return f'{method}_{safe}'\n",
    "system_prompt": {
      "text": "You write pytest test stubs for FastAPI endpoints.",
      "role": null,
      "capabilities": []
    },
    "methods": [
      {
        "name": "generate_tests",
        "input_schema": {
          "fields": {
            "endpoints": "list",
            "service_name": "str"
          },
          "description": null
        },
        "output_schema": {
          "fields": {
            "test_code": "str"
          },
          "description": null
        },
        "description": "Generate pytest test stubs covering all endpoints."
      }
    ],
    "subscriptions": [
      {
        "node_name": "TestAgent",
        "topic": "/Service/Generated",
        "handler_name": "on_service_generated"
      }
    ],
    "dependencies": [
      "RouterAgent"
    ],
    "is_arbiter": false,
    "metadata": {}
  }
]